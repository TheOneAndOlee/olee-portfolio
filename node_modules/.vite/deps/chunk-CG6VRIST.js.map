{
  "version": 3,
  "sources": ["../../svelte-typewriter/package/helpers/getLettersTimeout.js", "../../svelte-typewriter/package/helpers/getRandomLetter.js", "../../svelte-typewriter/package/modes/scramble.js"],
  "sourcesContent": ["import { rng } from './rng'\r\n\r\n// returns a array with a timeout (in ms) for each letter of the word\r\nexport const getLettersTimeout = (textLetters, timeout) => {\r\n\tconst minimumTimeoutPossible = timeout / 3\r\n\t// TODO: find a better way to deal with this instead of explicitly reducing the maximum timeout\r\n\t// otherwise, at the end of the animation, one or two characters remain scrambled\r\n\tconst lettersTimeout = textLetters.map(() => rng(minimumTimeoutPossible, timeout - 100))\r\n\treturn lettersTimeout\r\n}\r\n", "import { rng } from './rng'\r\n\r\nexport const getRandomLetter = () => {\r\n\tconst possibleLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split(\r\n\t\t''\r\n\t)\r\n\tconst letterIndexLimit = possibleLetters.length\r\n\tconst randomLetterIndex = rng(0, letterIndexLimit)\r\n\tconst randomLetter = possibleLetters[randomLetterIndex]\r\n\treturn randomLetter\r\n}\r\n", "import { getLettersTimeout } from '../helpers/getLettersTimeout'\r\nimport { getRandomLetter } from '../helpers/getRandomLetter'\r\nimport { rng } from '../helpers/rng'\r\nimport { sleep } from '../helpers/sleep'\r\nimport { runOnEveryParentUntil } from '../helpers/runOnEveryParentUntil'\r\nimport { animationSetup } from '../helpers/animationSetup'\r\n\r\n/**\r\n * @typedef {object} Props\r\n * @property {number} [interval]\r\n * @property {boolean} [cursor]\r\n * @property {boolean} [keepCursorOnFinish]\r\n * @property {number} [delay]\r\n * @property {boolean} [showCursorOnDelay]\r\n * @property {boolean} [disabled]\r\n * @property {string} [element]\r\n * @property {number} [scrambleDuration]\r\n * @property {number} [scrambleSlowdown]\r\n * @property {number} [unwriteInterval]\r\n * @property {number} [wordInterval]\r\n */\r\n\r\n/**\r\n * @typedef {{ update: () => void, destroy: () => void }} SvelteActionReturnType\r\n */\r\n\r\n/**\r\n * @typedef {(node: HTMLElement, props: Props) => SvelteActionReturnType} TypewriterModeFn\r\n */\r\n\r\n/**\r\n * @type {TypewriterModeFn}\r\n */\r\nconst scramble = async (node, props) => {\r\n\tconst { options, elements } = animationSetup(node, props)\r\n\r\n\tconst timeout = options.scrambleDuration\r\n\r\n\tawait new Promise(resolve => {\r\n\t\telements.forEach(async ({ currentNode, text }) => {\r\n\t\t\tlet wordLetters = text.split('')\r\n\t\t\tconst lettersTimeout = getLettersTimeout(wordLetters, timeout)\r\n\t\t\tconst startingTime = Date.now()\r\n\r\n\t\t\trunOnEveryParentUntil(currentNode, options.parentElement, element => {\r\n\t\t\t\telement.classList.add('finished-typing')\r\n\t\t\t})\r\n\r\n\t\t\twhile (Date.now() - startingTime < timeout) {\r\n\t\t\t\tconst randomLetterIndex = rng(0, wordLetters.length)\r\n\t\t\t\tconst randomLetterTimeout = lettersTimeout[randomLetterIndex]\r\n\t\t\t\tconst isRandomLetterWhitespace = wordLetters[randomLetterIndex] === ' '\r\n\t\t\t\tconst timeEllapsed = () => Date.now() - startingTime\r\n\t\t\t\tconst didRandomLetterReachTimeout = () => timeEllapsed() >= randomLetterTimeout\r\n\r\n\t\t\t\tif (didRandomLetterReachTimeout() || isRandomLetterWhitespace) {\r\n\t\t\t\t\tconst letterFinishedAnimation =\r\n\t\t\t\t\t\twordLetters[randomLetterIndex] === text[randomLetterIndex]\r\n\r\n\t\t\t\t\tif (!letterFinishedAnimation)\r\n\t\t\t\t\t\twordLetters[randomLetterIndex] = text[randomLetterIndex]\r\n\t\t\t\t\telse continue\r\n\t\t\t\t} else {\r\n\t\t\t\t\twordLetters[randomLetterIndex] = getRandomLetter()\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst scrambledText = wordLetters.join('')\r\n\t\t\t\tcurrentNode.innerHTML = scrambledText\r\n\r\n\t\t\t\tconst finishedScrambling = scrambledText === text\r\n\r\n\t\t\t\tconst letterInterval = options.scrambleSlowdown\r\n\t\t\t\t\t? Math.round(timeEllapsed() / 100)\r\n\t\t\t\t\t: 1\r\n\r\n\t\t\t\tawait sleep(letterInterval)\r\n\r\n\t\t\t\tif (finishedScrambling) {\r\n\t\t\t\t\tresolve()\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcurrentNode.innerHTML = text\r\n\t\t})\r\n\t})\r\n\r\n\toptions.dispatch('done')\r\n\r\n\treturn {\r\n\t\tupdate() {},\r\n\t\tdestroy() {}\r\n\t}\r\n}\r\n\r\nexport default scramble\r\n"],
  "mappings": ";;;;;;;;AAGO,IAAM,oBAAoB,CAAC,aAAa,YAAY;AAC1D,QAAM,yBAAyB,UAAU;AAGzC,QAAM,iBAAiB,YAAY,IAAI,MAAM,IAAI,wBAAwB,UAAU,GAAG,CAAC;AACvF,SAAO;AACR;;;ACPO,IAAM,kBAAkB,MAAM;AACpC,QAAM,kBAAkB,iEAAiE;AAAA,IACxF;AAAA,EACD;AACA,QAAM,mBAAmB,gBAAgB;AACzC,QAAM,oBAAoB,IAAI,GAAG,gBAAgB;AACjD,QAAM,eAAe,gBAAgB,iBAAiB;AACtD,SAAO;AACR;;;ACuBA,IAAM,WAAW,OAAO,MAAM,UAAU;AACvC,QAAM,EAAE,SAAS,SAAS,IAAI,eAAe,MAAM,KAAK;AAExD,QAAM,UAAU,QAAQ;AAExB,QAAM,IAAI,QAAQ,aAAW;AAC5B,aAAS,QAAQ,OAAO,EAAE,aAAa,KAAK,MAAM;AACjD,UAAI,cAAc,KAAK,MAAM,EAAE;AAC/B,YAAM,iBAAiB,kBAAkB,aAAa,OAAO;AAC7D,YAAM,eAAe,KAAK,IAAI;AAE9B,4BAAsB,aAAa,QAAQ,eAAe,aAAW;AACpE,gBAAQ,UAAU,IAAI,iBAAiB;AAAA,MACxC,CAAC;AAED,aAAO,KAAK,IAAI,IAAI,eAAe,SAAS;AAC3C,cAAM,oBAAoB,IAAI,GAAG,YAAY,MAAM;AACnD,cAAM,sBAAsB,eAAe,iBAAiB;AAC5D,cAAM,2BAA2B,YAAY,iBAAiB,MAAM;AACpE,cAAM,eAAe,MAAM,KAAK,IAAI,IAAI;AACxC,cAAM,8BAA8B,MAAM,aAAa,KAAK;AAE5D,YAAI,4BAA4B,KAAK,0BAA0B;AAC9D,gBAAM,0BACL,YAAY,iBAAiB,MAAM,KAAK,iBAAiB;AAE1D,cAAI,CAAC;AACJ,wBAAY,iBAAiB,IAAI,KAAK,iBAAiB;AAAA,cACnD;AAAA,QACN,OAAO;AACN,sBAAY,iBAAiB,IAAI,gBAAgB;AAAA,QAClD;AAEA,cAAM,gBAAgB,YAAY,KAAK,EAAE;AACzC,oBAAY,YAAY;AAExB,cAAM,qBAAqB,kBAAkB;AAE7C,cAAM,iBAAiB,QAAQ,mBAC5B,KAAK,MAAM,aAAa,IAAI,GAAG,IAC/B;AAEH,cAAM,MAAM,cAAc;AAE1B,YAAI,oBAAoB;AACvB,kBAAQ;AACR;AAAA,QACD;AAAA,MACD;AAEA,kBAAY,YAAY;AAAA,IACzB,CAAC;AAAA,EACF,CAAC;AAED,UAAQ,SAAS,MAAM;AAEvB,SAAO;AAAA,IACN,SAAS;AAAA,IAAC;AAAA,IACV,UAAU;AAAA,IAAC;AAAA,EACZ;AACD;AAEA,IAAO,mBAAQ;",
  "names": []
}
